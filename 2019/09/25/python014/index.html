<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/b.jpg?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="网络编程入门计算机网络基础计算机网络是独立自主的计算机互联而成的系统总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。是一个“复杂巨系统”。计算机发展史 1960s,美国国防部ARPANET项目问世，奠定了分组交换网络的基础 1980s,国际标准化组织ISO发布了OSI/RM,奠定了网络技术标准化的基础 1990s,英国人蒂姆·伯纳斯·李 发明了图形化的浏览器，浏览器的简单易用">
<meta property="og:type" content="article">
<meta property="og:title" content="python014">
<meta property="og:url" content="http://bayhax.github.io/2019/09/25/python014/index.html">
<meta property="og:site_name" content="bayhax的博客">
<meta property="og:description" content="网络编程入门计算机网络基础计算机网络是独立自主的计算机互联而成的系统总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。是一个“复杂巨系统”。计算机发展史 1960s,美国国防部ARPANET项目问世，奠定了分组交换网络的基础 1980s,国际标准化组织ISO发布了OSI/RM,奠定了网络技术标准化的基础 1990s,英国人蒂姆·伯纳斯·李 发明了图形化的浏览器，浏览器的简单易用">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://bayhax.github.io/2019/09/25/python014/python014_1.png">
<meta property="og:image" content="http://bayhax.github.io/2019/09/25/python014/python014_2.png">
<meta property="og:image" content="http://bayhax.github.io/2019/09/25/python014/python014_3.jpg">
<meta property="og:image" content="http://bayhax.github.io/2019/09/25/python014/python014_4.jpg">
<meta property="og:image" content="http://bayhax.github.io/2019/09/25/python014/python014_5.png">
<meta property="og:updated_time" content="2019-10-08T13:44:30.484Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python014">
<meta name="twitter:description" content="网络编程入门计算机网络基础计算机网络是独立自主的计算机互联而成的系统总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。是一个“复杂巨系统”。计算机发展史 1960s,美国国防部ARPANET项目问世，奠定了分组交换网络的基础 1980s,国际标准化组织ISO发布了OSI/RM,奠定了网络技术标准化的基础 1990s,英国人蒂姆·伯纳斯·李 发明了图形化的浏览器，浏览器的简单易用">
<meta name="twitter:image" content="http://bayhax.github.io/2019/09/25/python014/python014_1.png">
  <link rel="canonical" href="http://bayhax.github.io/2019/09/25/python014/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>python014 | bayhax的博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bayhax的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">学习交流</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">23</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-schedule">
      
    
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://bayhax.github.io/2019/09/25/python014/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王洪粮">
      <meta itemprop="description" content="坚持  自律   幽默  乐观 向上">
      <meta itemprop="image" content="/images/bayhax.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bayhax的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">python014

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-09-25 21:45:12" itemprop="dateCreated datePublished" datetime="2019-09-25T21:45:12+08:00">2019-09-25</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-08 21:44:30" itemprop="dateModified" datetime="2019-10-08T21:44:30+08:00">2019-10-08</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="网络编程入门"><a href="#网络编程入门" class="headerlink" title="网络编程入门"></a>网络编程入门</h1><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><p>计算机网络是独立自主的计算机互联而成的系统总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。是一个“复杂巨系统”。</p><h3 id="计算机发展史"><a href="#计算机发展史" class="headerlink" title="计算机发展史"></a>计算机发展史</h3><ol>
<li>1960s,美国国防部ARPANET项目问世，奠定了分组交换网络的基础<br><img src="//bayhax.github.io/2019/09/25/python014/python014_1.png" alt></li>
<li>1980s,国际标准化组织ISO发布了OSI/RM,奠定了网络技术标准化的基础<br><img src="//bayhax.github.io/2019/09/25/python014/python014_2.png" alt></li>
<li>1990s,英国人蒂姆·伯纳斯·李<br> 发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速普及<br><img src="//bayhax.github.io/2019/09/25/python014/python014_3.jpg" alt><br><img src="//bayhax.github.io/2019/09/25/python014/python014_4.jpg" alt></li>
</ol><a id="more"></a>

<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p>实现网络通信的基础是网络通信协议，这些协议通常是由互联网工程任务组IETF制定的，所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接<br>怎样互相识别等，网络协议的三要素：语法 语义 时序。构成我们今天使用的<br>Internet的基础是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信<br>模型，通常也把这套东西称为TCP/IP模型。与国际化标准组织的OSI/RM七层模型<br>不同，TCP/IP是一个四层模型。自底向上依次为：网络接口层、网络层、传输层<br>和应用层。<br><img src="//bayhax.github.io/2019/09/25/python014/python014_5.png" alt><br>IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个局域网（LAN）中的内部IP地址，通过网络地址转换（NAT）服务我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“路由器”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。</p>
<p>TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情：</p>
<ol>
<li>数据不传丢不传错（利用握手、校验和重传机制可以实现）。</li>
<li>流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。</li>
<li>拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。</li>
</ol>
<h3 id="网络应用模式"><a href="#网络应用模式" class="headerlink" title="网络应用模式"></a>网络应用模式</h3><ol>
<li>C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问</li>
<li>去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。</li>
</ol>
<h2 id="基于HTTP协议的网络资源访问"><a href="#基于HTTP协议的网络资源访问" class="headerlink" title="基于HTTP协议的网络资源访问"></a>基于HTTP协议的网络资源访问</h2><p><strong>HTTP 超文本传输协议</strong><br>HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是万维网数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法，通过HTTP或者HTTPS（超文本传输安全协议）请求的资源由URI（统一资源标识符）来标识。关于HTTP的更多内容，推荐阅读阮一峰老师的《HTTP 协议入门》，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。<br><strong>JSON格式</strong><br>JSON（JavaScript Object Notation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和XML一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅<br>XML的例子：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt;
&lt;message&gt;
        &lt;from&gt;Alice&lt;/from&gt;
        &lt;to&gt;Bob&lt;/to&gt;
        &lt;content&gt;Will you marry me?&lt;/content&gt;
&lt;/message&gt;</code></pre><p>JSON的例子：</p>
<pre><code>{
    &quot;from&quot;: &quot;Alice&quot;,
    &quot;to&quot;: &quot;Bob&quot;,
    &quot;content&quot;: &quot;Will you marray me?&quot;
}</code></pre><p><strong>requests库</strong><br>requests是一个基于HTTP协议来使用网络的第三方库，“Requestes是唯一的一个非转基因的Python HTTP库，人类可以安全享用”，也就说明了requests库可以非常方<br>便的使用HTTP，避免安全缺陷、冗余代码以及“重复造轮子”<br>利用requests库</p>
<pre><code>from time import time
from threading import Thread

import requests


#继承Thread类创建自定义的线程类
class DownloadHandler(Thread):

    def __init__(self, url):
        super().__init__()
        self.url = url

    def run(self):
        filename = self.url[self.url.rfind(&apos;/&apos;) + 1:]
        resp = requests.get(self.url)
        with open(&apos;/Users/bayahx/&apos; + filename, &apos;wb&apos;) as f:
            f.write(resp.content)


def main():
    # 通过requestes模块的get函数获取网络资源
    # 使用了天行数据接口提供的网络API
    # 要使用该数据接口需要在天行数据的网站上注册
    # 然后用自己的key替换掉下面的APIkey即可
    resp = requests.get(
        &apos;http://api.tianapi.com/meinv/?key=APIKey&amp;num=10&apos;)
    # 将服务器返回的json格式的数据解析为字典
    data_model = resp.json()
    for mm_dict in data_model[&apos;newslist&apos;]:
        url = mm_dict[&apos;picUrl&apos;]
        # 通过多线程的方式实现图片下载
        DownloadHandler(url).start()

if __name__ == &quot;__main__&quot;:
    main()</code></pre><h2 id="基于传输层协议的套接字编程"><a href="#基于传输层协议的套接字编程" class="headerlink" title="基于传输层协议的套接字编程"></a>基于传输层协议的套接字编程</h2><p>通俗来说，套接字就是一套用C语言编写成的应用程序开发库，主要永不实现进程间<br>通信和网络编程，在网络开发中被广泛应用，在python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字</p>
<h3 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h3><p>所谓TCP套接字就是用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并制定type属性为SOCK_STREAM来使用TCP套接字。<br>由于一台主机可能同时拥有多个IP地址，而且很有可能会配置不同的服务，多以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如HTTP服务绑定80端口，MySQL数据库服务默认绑定3306端口等。这样服务器收到用户请求后便知道请求的是什么服务。端口取值范围为0-65535，,1024以下的端口为“著名端口”留给FTP/HTTP/SMTP使用，自定义的服务不使用这些端口，除非自定义的<br>是HTTP这样的著名服务<br>实现提供时间日期的服务器</p>
<pre><code>from socket import socket, SOCK_STREAM, AF_INET
from datetime import datetime

def main():
    # 1.创建套接字对象并制定使用哪种传输服务
    # family=AF_INET  -IPv4地址
    # family=AF_INET6  -IPv6地址
    # type=SOCK_STREAM  -TCP套接字
    # type=SOCK_DGRAM  -UDP套接字
    # type=SOCK_RAW  -原始套接字
    server = socket(family=AF_INET, type=SOCK_STREAM)
    # 2.绑定IP地址和端口
    # 同一时间在同一个端口上只能绑定一个服务否则报错
    server.bind((&quot;192.168.1.3&quot;, 6789))
    # 3.开启监听   -监听客户端连接到服务器
    # 参数为512可以理解为连接队列的大小
    server.listen(512)
    pirnt(&quot;服务器启动开始监听&quot;)
    while True:
        # 4.通过循环接收客户端的连接并作出相应的处理(提供服务)
        # accept方法是一个阻塞方法，如果没有客户端连接到服务器
        # 代码不会向下执行，accept方法返回的是一个元组，其中第
        # 一个元素是客户端对象，第二个元素是连接到服务器的客户
        # 端的地址（ip和端口两部分构成）
        client, addr = server.accept()
        print(str(addr) + &apos;连接到了服务器&apos;)
        # 5.发送数据
        client.send(str(datetime.now()).encode(&apos;utf-8&apos;))
        # 6.断开连接
        client.close()

if __name__ == &quot;__main__&quot;:
    main()</code></pre><p>通过Python实现TCP客户端功能</p>
<pre><code>from socket import socket

def main():
    # 1.创建套接字对象默认使用IPv4和TCP协议
    client = socket()
    # 2.连接到服务器(需要指定IP地址和端口)
    client.connect((&apos;192.1681.1.3&apos;, 6789))
    # 3.从服务器接收数据
    print(client.recv(1024).decode(&apos;utf-8&apos;))
    # 4.关闭客户端
    client.close()

if __name__ == &quot;__main__&quot;:
    main() </code></pre><p>很显然上面没有使用多线程，当多个客户端连接服务器时，只能排队等待，一个连接完成断开以后才能连接下一个，效率低下。下面使用多线程技术处理多个用户请求的服务器<br>服务器端代码：</p>
<pre><code>from socket import socket, SOCK_STREAM, AF_INET
from base64 import b64encode
from json import dumps
from threading import Thread


def main():

    # 自定义线程类
    class FileTransferHandler(Thread):

        def __init__(self, cclient):
            super().__init__()
            self.cclient = cclient

        def run(self):
            my_dict = {}
            my_dict[&apos;filename&apos;] = &apos;guido.jpg&apos;
            # JSON是纯文本不能携带二进制数据
            # 所以图片的二进制数据要处理成base64编码
            my_dict[&apos;filedata&apos;] = data
            # 通过dumps函数将字典处理成JSON字符串
            json_str = dumps(my_dict)
            # 发送JSON字符串
            self.cclient.send(json_str.encode(&apos;utf-8&apos;))
            self.cclient.close()

    # 1.创建套接字对象并指定使用哪种传输服务
    server = socket()
    # 2.绑定IP地址和端口(区分不同的服务)
    server.bind((&apos;192.168.1.2&apos;, 5566))
    # 3.开启监听 - 监听客户端连接到服务器
    server.listen(512)
    print(&apos;服务器启动开始监听...&apos;)
    with open(&apos;guido.jpg&apos;, &apos;rb&apos;) as f:
        # 将二进制数据处理成base64再解码成字符串
        data = b64encode(f.read()).decode(&apos;utf-8&apos;)
    while True:
        client, addr = server.accept()
        # 启动一个线程来处理客户端的请求
        FileTransferHandler(client).start()


if __name__ == &apos;__main__&apos;:
    main()</code></pre><p>客户端代码：</p>
<pre><code>from socket import socket
from json import loads
from base64 import b64decode


def main():
    client = socket()
    client.connect((&apos;192.168.1.2&apos;, 5566))
    # 定义一个保存二进制数据的对象
    in_data = bytes()
    # 由于不知道服务器发送的数据有多大每次接收1024字节
    data = client.recv(1024)
    while data:
        # 将收到的数据拼接起来
        in_data += data
        data = client.recv(1024)
    # 将收到的二进制数据解码成JSON字符串并转换成字典
    # loads函数的作用就是将JSON字符串转成字典对象
    my_dict = loads(in_data.decode(&apos;utf-8&apos;))
    filename = my_dict[&apos;filename&apos;]
    filedata = my_dict[&apos;filedata&apos;].encode(&apos;utf-8&apos;)
    with open(&apos;/Users/Hao/&apos; + filename, &apos;wb&apos;) as f:
        # 将base64格式的数据解码成二进制数据并写入文件
        f.write(b64decode(filedata))
    print(&apos;图片已保存.&apos;)


if __name__ == &apos;__main__&apos;:
    main()</code></pre><p>在案例中，使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0到9的数字、大小写字母以及”+“和”/“总共64个字符表示从000000到111111的64种<br>状态。</p>
<h3 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h3><p>传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用</p>
<h2 id="网络应用开发"><a href="#网络应用开发" class="headerlink" title="网络应用开发"></a>网络应用开发</h2><h3 id="发送电子邮件"><a href="#发送电子邮件" class="headerlink" title="发送电子邮件"></a>发送电子邮件</h3><p>就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。<br>python发送邮件</p>
<pre><code>from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText


def main():
    # 请自行修改下面的邮件发送者和接收者
    sender = &apos;abcdefg@126.com&apos;
    receivers = [&apos;uvwxyz@qq.com&apos;, &apos;uvwxyz@126.com&apos;]
    message = MIMEText(&apos;用Python发送邮件的示例代码.&apos;, &apos;plain&apos;, &apos;utf-8&apos;)
    message[&apos;From&apos;] = Header(&apos;王大锤&apos;, &apos;utf-8&apos;)
    message[&apos;To&apos;] = Header(&apos;骆昊&apos;, &apos;utf-8&apos;)
    message[&apos;Subject&apos;] = Header(&apos;示例代码实验邮件&apos;, &apos;utf-8&apos;)
    smtper = SMTP(&apos;smtp.126.com&apos;)
    # 请自行修改下面的登录口令
    smtper.login(sender, &apos;secretpass&apos;)
    smtper.sendmail(sender, receivers, message.as_string())
    print(&apos;邮件发送完成!&apos;)


if __name__ == &apos;__main__&apos;:
    main()</code></pre><p>发送带有附件的邮件</p>
<pre><code>from smtplib import SMTP
from email.header import Header
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart

import urllib


def main():
    # 创建一个带附件的邮件消息对象
    message = MIMEMultipart()

    # 创建文本内容
    text_content = MIMEText(&apos;附件中有本月数据请查收&apos;, &apos;plain&apos;, &apos;utf-8&apos;)
    message[&apos;Subject&apos;] = Header(&apos;本月数据&apos;, &apos;utf-8&apos;)
    # 将文本内容添加到邮件消息对象中
    message.attach(text_content)

    # 读取文件并将文件作为附件添加到邮件消息对象中
    with open(&apos;/Users/Hao/Desktop/hello.txt&apos;, &apos;rb&apos;) as f:
        txt = MIMEText(f.read(), &apos;base64&apos;, &apos;utf-8&apos;)
        txt[&apos;Content-Type&apos;] = &apos;text/plain&apos;
        txt[&apos;Content-Disposition&apos;] = &apos;attachment; filename=hello.txt&apos;
        message.attach(txt)
    # 读取文件并将文件作为附件添加到邮件消息对象中
    with open(&apos;/Users/Hao/Desktop/汇总数据.xlsx&apos;, &apos;rb&apos;) as f:
        xls = MIMEText(f.read(), &apos;base64&apos;, &apos;utf-8&apos;)
        xls[&apos;Content-Type&apos;] = &apos;application/vnd.ms-excel&apos;
        xls[&apos;Content-Disposition&apos;] = &apos;attachment; filename=month-data.xlsx&apos;
        message.attach(xls)

    # 创建SMTP对象
    smtper = SMTP(&apos;smtp.126.com&apos;)
    # 开启安全连接
    # smtper.starttls()
    sender = &apos;abcdefg@126.com&apos;
    receivers = [&apos;uvwxyz@qq.com&apos;]
    # 登录到SMTP服务器
    # 请注意此处不是使用密码而是邮件客户端授权码进行登录
    # 对此有疑问的读者可以联系自己使用的邮件服务器客服
    smtper.login(sender, &apos;secretpass&apos;)
    # 发送邮件
    smtper.sendmail(sender, receivers, message.as_string())
    # 与邮件服务器断开连接
    smtper.quit()
    print(&apos;发送完成!&apos;)


if __name__ == &apos;__main__&apos;:
    main()</code></pre><h3 id="发送短信"><a href="#发送短信" class="headerlink" title="发送短信"></a>发送短信</h3><p>在下面的代码中我们使用了互亿无线短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p>
<pre><code>import urllib.parse
import http.client
import json


def main():
    host  = &quot;106.ihuyi.com&quot;
    sms_send_uri = &quot;/webservice/sms.php?method=Submit&quot;
    # 下面的参数需要填入自己注册的账号和对应的密码
    params = urllib.parse.urlencode({&apos;account&apos;: &apos;你自己的账号&apos;, &apos;password&apos; : &apos;你自己的密码&apos;, &apos;content&apos;: &apos;您的验证码是：147258。请不要把验证码泄露给其他人。&apos;, &apos;mobile&apos;: &apos;接收者的手机号&apos;, &apos;format&apos;:&apos;json&apos; })
    print(params)
    headers = {&apos;Content-type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;Accept&apos;: &apos;text/plain&apos;}
    conn = http.client.HTTPConnection(host, port=80, timeout=30)
    conn.request(&apos;POST&apos;, sms_send_uri, params, headers)
    response = conn.getresponse()
    response_str = response.read()
    jsonstr = response_str.decode(&apos;utf-8&apos;)
    print(json.loads(jsonstr))
    conn.close()


if __name__ == &apos;__main__&apos;:
    main()</code></pre>
    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/09/23/python013/" rel="next" title="python013">
                  <i class="fa fa-chevron-left"></i> python013
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/10/08/python015/" rel="prev" title="python015">
                  python015 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程入门"><span class="nav-number">1.</span> <span class="nav-text">网络编程入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机网络基础"><span class="nav-number">1.1.</span> <span class="nav-text">计算机网络基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机发展史"><span class="nav-number">1.1.1.</span> <span class="nav-text">计算机发展史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP模型"><span class="nav-number">1.1.2.</span> <span class="nav-text">TCP/IP模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络应用模式"><span class="nav-number">1.1.3.</span> <span class="nav-text">网络应用模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于HTTP协议的网络资源访问"><span class="nav-number">1.2.</span> <span class="nav-text">基于HTTP协议的网络资源访问</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于传输层协议的套接字编程"><span class="nav-number">1.3.</span> <span class="nav-text">基于传输层协议的套接字编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP套接字"><span class="nav-number">1.3.1.</span> <span class="nav-text">TCP套接字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP套接字"><span class="nav-number">1.3.2.</span> <span class="nav-text">UDP套接字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络应用开发"><span class="nav-number">1.4.</span> <span class="nav-text">网络应用开发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发送电子邮件"><span class="nav-number">1.4.1.</span> <span class="nav-text">发送电子邮件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送短信"><span class="nav-number">1.4.2.</span> <span class="nav-text">发送短信</span></a></li></ol></li></ol></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/bayhax.jpg"
      alt="王洪粮">
  <p class="site-author-name" itemprop="name">王洪粮</p>
  <div class="site-description" itemprop="description">坚持  自律   幽默  乐观 向上</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/bayhax" title="GitHub &rarr; https://github.com/bayhax" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:whlbayhax@gmail.com" title="E-Mail &rarr; mailto:whlbayhax@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">by bayhax</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
