<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/b.jpg?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Python语言进阶 数据结构和算法 算法：解决问题的方法和步骤 评价算法的好坏：渐进时间复杂度和渐进空间复杂度  O(c)-常量时间复杂度-布隆过滤器/哈希存储  O(log2n)-对数时间复杂度-折半查找（二分查找）  O(n)-线性时间复杂度-顺序查找/桶排序  O(n*log2n)-对数线性时间复杂度-高级排序算法(归并排序，快速排序)  O(n^2)-平方时间复杂度-简单排序算法(选择、">
<meta property="og:type" content="article">
<meta property="og:title" content="Python语言进阶">
<meta property="og:url" content="http://bayhax.github.io/2019/10/10/Python语言进阶/index.html">
<meta property="og:site_name" content="bayhax的博客">
<meta property="og:description" content="Python语言进阶 数据结构和算法 算法：解决问题的方法和步骤 评价算法的好坏：渐进时间复杂度和渐进空间复杂度  O(c)-常量时间复杂度-布隆过滤器/哈希存储  O(log2n)-对数时间复杂度-折半查找（二分查找）  O(n)-线性时间复杂度-顺序查找/桶排序  O(n*log2n)-对数线性时间复杂度-高级排序算法(归并排序，快速排序)  O(n^2)-平方时间复杂度-简单排序算法(选择、">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-10-16T12:26:47.551Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python语言进阶">
<meta name="twitter:description" content="Python语言进阶 数据结构和算法 算法：解决问题的方法和步骤 评价算法的好坏：渐进时间复杂度和渐进空间复杂度  O(c)-常量时间复杂度-布隆过滤器/哈希存储  O(log2n)-对数时间复杂度-折半查找（二分查找）  O(n)-线性时间复杂度-顺序查找/桶排序  O(n*log2n)-对数线性时间复杂度-高级排序算法(归并排序，快速排序)  O(n^2)-平方时间复杂度-简单排序算法(选择、">
  <link rel="canonical" href="http://bayhax.github.io/2019/10/10/Python语言进阶/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Python语言进阶 | bayhax的博客</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bayhax的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">学习交流</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-about">
      
    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">0</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">23</span></a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-schedule">
      
    
      
    

    <a href="/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://bayhax.github.io/2019/10/10/Python语言进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="王洪粮">
      <meta itemprop="description" content="坚持  自律   幽默  乐观 向上">
      <meta itemprop="image" content="/images/bayhax.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bayhax的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Python语言进阶

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-10 20:57:46" itemprop="dateCreated datePublished" datetime="2019-10-10T20:57:46+08:00">2019-10-10</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-16 20:26:47" itemprop="dateModified" datetime="2019-10-16T20:26:47+08:00">2019-10-16</time>
              </span>
            
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Python语言进阶"><a href="#Python语言进阶" class="headerlink" title="Python语言进阶"></a>Python语言进阶</h1><ol>
<li>数据结构和算法<ul>
<li>算法：解决问题的方法和步骤</li>
<li>评价算法的好坏：渐进时间复杂度和渐进空间复杂度<br>  O(c)-常量时间复杂度-布隆过滤器/哈希存储<br>  O(log2n)-对数时间复杂度-折半查找（二分查找）<br>  O(n)-线性时间复杂度-顺序查找/桶排序<br>  O(n*log2n)-对数线性时间复杂度-高级排序算法(归并排序，快速排序)<br>  O(n^2)-平方时间复杂度-简单排序算法(选择、插入、冒泡)<br>  O(“n^3)-立方时间复杂度-Floyd算法/矩阵乘法运算<br>  O(2^n)-几何级数时间复杂度-汉诺塔<br>  O(n!)-阶乘时间复杂度-旅行经销商问题-NP</li>
<li>排序算法（选择 冒泡  归并）查找算法（顺序  折半）<br><strong>选择排序：</strong></li>
</ul>
</li>
</ol><a id="more"></a>
<pre><code>    def select_sort(origin_items, comp=lambda x,y:x &lt; y):
        &apos;&apos;&apos;简单选择排序&apos;&apos;&apos;
        items = origin_items[:]
        for i in range(len(items) - 1):
            min_index = i
            for j in range(i +1, len(items)):
                if comp(items[j], items[min_index]):
                    min_index = j
            items[i], items[min_index] = items[min_index], items[i]
        return items

冒泡排序：

    def bubble_sort(origin_items, comp=lambda x, y : x &gt; y):
        &apos;&apos;&apos;高质量冒泡排序（搅拌排序）&apos;&apos;&apos;
        items = origin_items[:]
        for i in range(len(items) - 1):
            swapped = False
            for j in range(i, len(items) - 1 - i):
                if comp(items[j], items[j+1]):
                    items[j], items[j+1] = items[j+1],items[j]
                    swapped = True
            if swapped:
                swapped = False
                for j in range(len(items) - 2 - i, i, -1):
                    if comp(items[j - 1], items[j]):
                        items[j],items[j-1]=items[j-1],items[j]
                        swapped = True
            if not swapped:
                break
        return items

    def merge_sort(items, comp=lambda x, y: x &lt;= y):
        &quot;&quot;&quot;归并排序(分治法)&quot;&quot;&quot;
        if len(items) &lt; 2:
            return items[:]
        mid = len(items) // 2
        left = merge_sort(items[:mid], comp)
        right = merge_sort(items[mid:], comp)
        return merge(left, right, comp)
    def merge(items1, items2, comp):
        &quot;&quot;&quot;合并(将两个有序的列表合并成一个有序的列表)&quot;&quot;&quot;
        items = []
        index1, index2 = 0, 0
        while index1 &lt; len(items1) and index2 &lt; len(items2):
            if comp(items1[index1], items2[index2]):
                items.append(items1[index1])
                index1 += 1
            else:
                items.append(items2[index2])
        index2 += 1
        items += items1[index1:]
        items += items2[index2:]
        return items

    def seq_search(items, key):
        &quot;&quot;&quot;顺序查找&quot;&quot;&quot;
        for index, item in enumerate(items):
            if item == key:
                return index
        return -1

    def bin_search(items, key):
        &quot;&quot;&quot;折半查找&quot;&quot;&quot;
        start, end = 0, len(items) - 1
        while start &lt;= end:
            mid = (start + end) // 2
            if key &gt; items[mid]:
                start = mid + 1
            elif key &lt; items[mid]:
                end = mid - 1
            else:
                return mid
        return -1

* 使用生成式（推导式）语法

    prices = {
        &apos;AAPL&apos;: 191.88,
        &apos;GOOG&apos;: 1186.96,
        &apos;IBM&apos;: 149.24,
        &apos;ORCL&apos;: 48.44,
        &apos;ACN&apos;: 166.89,
        &apos;FB&apos;: 208.09,
        &apos;SYMC&apos;: 21.29
    }    
    # 用股票价格大于100元的股票构造一个新的字典
    prices2 = {key:value for key, value in prices.items() if value &gt; 100}
    print(prices2)
    # 生成式可以用来生成列表、集合、字典

* 嵌套的列表

    names = [&apos;关羽&apos;,&apos;张飞&apos;,&apos;赵云&apos;,&apos;马超&apos;,&apos;黄忠&apos;]
    courses = [&apos;语文&apos;,&apos;数学&apos;,&apos;英语&apos;]
    # 录入五个学生三门课程的成绩
    # scores = [[None] * len(courses)] * len&quot;(&apos;names&apos;)
    scores = [[None] * len(courses) for _ in range(len(names))]
    for row, name in enumerate(names):
        for col, course in enumerate(courses):
            scores[row][col] = float(input(f&apos;请输入{name}的{course}成绩：&apos;))
            print(scores)

* heapd、itertools等的用法

    &apos;&apos;&apos;
    从列表中找出最大的或最小的N个元素
    堆结构（大根堆、小根堆）
    &apos;&apos;&apos;
    import heapd
    list1 = [34,25,12,99,87,63,58,78,88,92]
    list2 = [
        {&apos;name&apos;: &apos;IBM&apos;, &apos;shares&apos;: 100, &apos;price&apos;: 91.1},
        {&apos;name&apos;: &apos;AAPL&apos;, &apos;shares&apos;: 50, &apos;price&apos;: 543.22},
        {&apos;name&apos;: &apos;FB&apos;, &apos;shares&apos;: 200, &apos;price&apos;: 21.09},
        {&apos;name&apos;: &apos;HPQ&apos;, &apos;shares&apos;: 35, &apos;price&apos;: 31.75},
        {&apos;name&apos;: &apos;YHOO&apos;, &apos;shares&apos;: 45, &apos;price&apos;: 16.35},
        {&apos;name&apos;: &apos;ACME&apos;, &apos;shares&apos;: 75, &apos;price&apos;: 115.65}
    ]
    print(heapq.nlargest(3, list1))
    print(heapd.nsmallest(3, list1))
    print(heapq.nlargest(2, list2, key=lambda x: x[&apos;price&apos;]))
    print(heap1.nlargest(2, list2, key=lambda x: x[&apos;shares&apos;]))

    &apos;&apos;&apos;
    迭代工具 -排列/组合/笛卡尔积
    &apos;&apos;&apos;
    import itertools
    itertools.permutations(&apos;ABCD&apos;)
    itertools.combinations(&apos;ABCD&apos;, 3)
    itertools.product(&apos;ABCD&apos;, &apos;123&apos;)

* collections模块下的工具类

    &apos;&apos;&apos;
    找出序列中出现次数最多的元素
    &apos;&apos;&apos;
    from collections impport Counter
    words = [
        &apos;look&apos;, &apos;into&apos;, &apos;my&apos;, &apos;eyes&apos;, &apos;look&apos;, &apos;into&apos;, &apos;my&apos;, &apos;eyes&apos;,&apos;the&apos;, &apos;eyes&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;the&apos;, &apos;eyes&apos;, &apos;not&apos;, &apos;around&apos;,&apos;the&apos;, &apos;eyes&apos;, &quot;don&apos;t&quot;, &apos;look&apos;, &apos;around&apos;, &apos;the&apos;, &apos;eyes&apos;,&apos;look&apos;, &apos;into&apos;, &apos;my&apos;, &apos;eyes&apos;, &quot;you&apos;re&quot;, &apos;under&apos;
    ]
    counter = Counter(words)
    print(counter.most_common(3))

* 常用算法
    * 穷举法 暴力破解法，对所有可能性进行验证，直到找到正确答案
    * 贪婪法 对问题进行求解时，总是以当前视角来看
    * 最好的选择  不追求最优解，快速找到满意解
    * 分治法 把一个复杂的问题分成两个或者更多的相同的或相似的子问题
      再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解
    * 回溯法  又称为试探法，按选优条件向前搜索，当搜索到某一步发现
      原先选择并不优或达不到目标时，就退回一步重新选择
    * 动态规划 将待求解问题分解成若干个子问题，先求解并保存这些子
      问题的解，避免产生大量的重复运算。
穷举法：百钱白鸡  五人分鱼

    # 公鸡5元一只 母鸡3元一只 小鸡1元三只
    # 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只
    for x in range(20):
        for y in range(33):
            z = 100 - x - y
            if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:
                print(x, y, z)

    # A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉
    # 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份
    # B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份
    # 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼
    fish = 6
    while True:
        total = fish
        enough = True
        for _ in range(5):
            if (total - 1) % 5 == 0:
                total = (total - 1) // 5 * 4
            else:
                enough = False
                break
        if enough:
            print(fish)
            break
        fish += 5

贪婪法： 假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发       现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须    确定拿走哪些物品，留下哪些物品。

| :-: | :-: | :-: |
|名称|价格（美元）|重量kg|
| :-: | :-: | :-: |
|电脑|200|20|
|收音机|20|4|
|钟|175|10|
|花瓶|50|2|
|书|10|1|
|油画|90|9|    

    &quot;&quot;&quot;
    贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。
    输入：
    20 6
    电脑 200 20
    收音机 20 4
    钟 175 10
    花瓶 50 2
    书 10 1
    油画 90 9
    &quot;&quot;&quot;
    class Thing(object):
        &quot;&quot;&quot;物品&quot;&quot;&quot;
    def __init__(self, name, price, weight):
        self.name = name
        self.price = price
        self.weight = weight
    @property
    def value(self):
        &quot;&quot;&quot;价格重量比&quot;&quot;&quot;
        return self.price / self.weight
    def input_thing():
        &quot;&quot;&quot;输入物品信息&quot;&quot;&quot;
        name_str, price_str, weight_str = input().split()
        return name_str, int(price_str), int(weight_str)
    def main():
        &quot;&quot;&quot;主函数&quot;&quot;&quot;
        max_weight, num_of_things = map(int, input().split())
        all_things = []
        for _ in range(num_of_things):
            all_things.append(Thing(*input_thing()))
        all_things.sort(key=lambda x: x.value, reverse=True)
        total_weight = 0
        total_price = 0
        for thing in all_things:
            if total_weight + thing.weight &lt;= max_weight:
                print(f&apos;小偷拿走了{thing.name}&apos;)
                total_weight += thing.weight
                total_price += thing.price
        print(f&apos;总价值: {total_price}美元&apos;)
    if __name__ == &apos;__main__&apos;:
        main()

分治法： 快速排序

    &quot;&quot;&quot;
    快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大
    &quot;&quot;&quot;
    def quick_sort(origin_items, comp=lambda x, y: x &lt;= y):
        items = origin_items[:]
        _quick_sort(items, 0, len(items) - 1, comp)
        return items
    def _quick_sort(items, start, end, comp):
        if start &lt; end:
            pos = _partition(items, start, end, comp)
            _quick_sort(items, start, pos - 1, comp)
            _quick_sort(items, pos + 1, end, comp)
    def _partition(items, start, end, comp):
        pivot = items[end]
        i = start - 1
        for j in range(start, end):
            if comp(items[j], pivot):
                i += 1
                items[i], items[j] = items[j], items[i]
        items[i + 1], items[end] = items[end], items[i + 1]
        return i + 1

回溯法：骑士巡逻

    &quot;&quot;&quot;
    递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。
    &quot;&quot;&quot;
    import sys
    import time
    SIZE = 5
    total = 0
    def print_board(board):
        for row in board:
            for col in row:
                print(str(col).center(4), end=&apos;&apos;)
            print()
    def patrol(board, row, col, step=1):
        if row &gt;= 0 and row &lt; SIZE and \
            col &gt;= 0 and col &lt; SIZE and \
            board[row][col] == 0:
            board[row][col] = step
            if step == SIZE * SIZE:
                global total
                total += 1
                print(f&apos;第{total}种走法: &apos;)
                print_board(board)
            patrol(board, row - 2, col - 1, step + 1)
            patrol(board, row - 1, col - 2, step + 1)
            patrol(board, row + 1, col - 2, step + 1)
            patrol(board, row + 2, col - 1, step + 1)
            patrol(board, row + 2, col + 1, step + 1)
            patrol(board, row + 1, col + 2, step + 1)
            patrol(board, row - 1, col + 2, step + 1)
            patrol(board, row - 2, col + 1, step + 1)
            board[row][col] = 0
    def main():
        board = [[0] * SIZE for _ in range(SIZE)]
        patrol(board, SIZE - 1, SIZE - 1)
    if __name__ == &apos;__main__&apos;:
        main()

动态规划例子1:斐波那契数列

    &quot;&quot;&quot;
    动态规划 - 适用于有重叠子问题和最优子结构性质的问题
    使用动态规划方法所耗时间往往远少于朴素解法(用空间换取时间)
    &quot;&quot;&quot;
    def fib(num, temp={}):
        &quot;&quot;&quot;用递归计算Fibonacci数&quot;&quot;&quot;
        if num in (1, 2):
            return 1
        try:
            return temp[num]
        except KeyError:
            temp[num] = fib(num - 1) + fib(num - 2)
            return temp[num]
动态规划例子2：子列表元素之和的最大值

    def main():
        items = list(map(int, input().split()))
        size = len(items)
        overall, partial = {}, {}
        overall[size - 1] = partial[size - 1] = items[size - 1]
        for i in range(size - 2, -1, -1):
            partial[i] = max(items[i], partial[i + 1] + items[i])
            overall[i] = max(partial[i], overall[i + 1])
        print(overall[0])
    if __name__ == &apos;__main__&apos;:
        main()</code></pre><ol start="2">
<li><p>函数的使用方式</p>
<ul>
<li><p>将函数视为“一等公民”<br>  函数可以赋值给变量<br>  函数可以作为函数的参数<br>  函数可以作为函数的返回值</p>
</li>
<li><p>高阶函数的用法（filter map以及他们的替代品）<br>  items = list(map(lambda x:x ** 2, filter(lambda x:x % 2, range(1, 10))))<br>  items2 = [x ** 2 for x in range(1,10) if x % 2]</p>
</li>
<li><p>位置参数 可变参数  关键字参数 命名关键字参数</p>
</li>
<li><p>参数的元信息（代码可读性问题）</p>
</li>
<li><p>匿名函数和内联函数的用法（lambda函数）</p>
</li>
<li><p>闭包和作用域问题<br>  Python搜索变量的LEGB顺序(Local-&gt;Embedded-&gt;Global-&gt;Built-in)<br>  global 和 nonlocal关键字的作用<br>  global：声明或定义全局变量<br>  nonlocal:声明使用嵌套作用域的变量（嵌套作用域必须存在该变量）</p>
</li>
<li><p>装饰器函数（使用装饰器和取消装饰器）<br>例如：输出函数执行时间的装饰器</p>
<p>  def record_time(func):</p>
<pre><code>&apos;&apos;&apos;自定义装饰函数的装饰器&apos;&apos;&apos;
@wraps(func)
def wrapper(*args, **kwargs):
    start = time()
    result = func(*args, **kwargs)
    print(f&apos;{func.__name__}:{time() - start}秒&apos;)
    return result
return wrapper</code></pre><p>如果装饰器不希望跟print函数耦合，可以编写带参数的装饰器</p>
<p>  from functools import warps<br>  from time import time<br>  def record(output):</p>
<pre><code>&apos;&apos;&apos;自定义带参数的装饰器&apos;&apos;&apos;
def decorate(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time()
        result = func(*args, **kwargs)
        output(func.__name__, time()- start)
        return result
return decorate</code></pre><p>  from functools import wraps<br>  from time import time<br>  class Record():</p>
<pre><code>&apos;&apos;&apos;自定义装饰器类（通过__call__魔术方法使得对象可以当成函数调用&apos;&apos;&apos;
def __init__(self, output):
    self.output = output
def __call__(self, func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time()
        result = func(*args, **kwargs)
        self.output(func.__name__, time() - start)
        return result
    return wrapper</code></pre><p>由于对带装饰功能的函数添加了@wraps装饰器，可以通过func.__wrapped__方式获得被装饰之前的函数或类来取消装饰器的作用</p>
<p>例：用装饰器来实现单例模式</p>
<p>  from functools import wraps<br>  def singleton(cls):</p>
<pre><code>&apos;&apos;&apos;装饰器类的装饰器&apos;&apos;&apos;
instances = {}
@wraps(cls)
def wrapper(*args, **kwargs):
    if cls not in instances:
        instances[cls] = cls(*args, **kwargs)
    return instances[cls]
return wrapper</code></pre><p>  @singleton<br>  class President():</p>
<pre><code>&apos;&apos;&apos;总统(单例类)&apos;&apos;&apos;
pass</code></pre><p>此代码中使用了闭包closure，但是有一个小问题，上面的代码并没有实现线程安全的单例，实现线程安全的单例</p>
<p>  from functools import wraps<br>  from threading import Lock<br>  def singleton(cls):</p>
<pre><code>&quot;&quot;&quot;线程安全的单例装饰器&quot;&quot;&quot;
instances = {}
locker = Lock()
@wraps(cls)
def wrapper(*args, **kwargs):
    if cls not in instances:
        with locker:
            if cls not in instances:
                instances[cls] = cls(*args, **kwargs)
    return instances[cls]
return wrapper</code></pre></li>
</ul>
</li>
<li><p>面向对象相关知识</p>
<ul>
<li><p>三大支柱：封装 继承 多态<br>例：工资结算系统</p>
<p>  “””<br>  月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成<br>  “””<br>  from abc import ABCMeta, abstractmethod<br>  class Employee(metaclass=ABCMeta):</p>
<pre><code>&quot;&quot;&quot;员工(抽象类)&quot;&quot;&quot;
def __init__(self, name):
    self.name = name
@abstractmethod
def get_salary(self):
    &quot;&quot;&quot;结算月薪(抽象方法)&quot;&quot;&quot;
    pass</code></pre><p>  class Manager(Employee):</p>
<pre><code>&quot;&quot;&quot;部门经理&quot;&quot;&quot;
def get_salary(self):
    return 15000.0</code></pre><p>  class Programmer(Employee):</p>
<pre><code>&quot;&quot;&quot;程序员&quot;&quot;&quot;
def __init__(self, name, working_hour=0):
    self.working_hour = working_hour
    super().__init__(name)
def get_salary(self):
    return 200.0 * self.working_hour</code></pre><p>  class Salesman(Employee):</p>
<pre><code>&quot;&quot;&quot;销售员&quot;&quot;&quot;
def __init__(self, name, sales=0.0):
    self.sales = sales
    super().__init__(name)
def get_salary(self):
    return 1800.0 + self.sales * 0.05</code></pre><p>  class EmployeeFactory():</p>
<pre><code>&quot;&quot;&quot;创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）&quot;&quot;&quot;
@staticmethod
def create(emp_type, *args, **kwargs):
    &quot;&quot;&quot;创建员工&quot;&quot;&quot;
    emp_type = emp_type.upper()
    emp = None
    if emp_type == &apos;M&apos;:
        emp = Manager(*args, **kwargs)
    elif emp_type == &apos;P&apos;:
        emp = Programmer(*args, **kwargs)
    elif emp_type == &apos;S&apos;:
        emp = Salesman(*args, **kwargs)
    return emp</code></pre><p>  def main():</p>
<pre><code>&quot;&quot;&quot;主函数&quot;&quot;&quot;
emps = [
    EmployeeFactory.create(&apos;M&apos;, &apos;曹操&apos;), 
    EmployeeFactory.create(&apos;P&apos;, &apos;荀彧&apos;, 120),
    EmployeeFactory.create(&apos;P&apos;, &apos;郭嘉&apos;, 85), 
    EmployeeFactory.create(&apos;S&apos;, &apos;典韦&apos;, 123000),
]
for emp in emps:
    print(&apos;%s: %.2f元&apos; % (emp.name, emp.get_salary()))</code></pre><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:</p>
<pre><code>main()</code></pre></li>
<li><p>类与类之间的关系<br>  is-a关系：继承<br>  has-a关系：关联/聚合/合成<br>  use-a关系：依赖<br>例：扑克游戏</p>
<p>  “””<br>  经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择<br>  “””<br>  from enum import Enum, unique<br>  import random<br>  @unique<br>  class Suite(Enum):</p>
<pre><code>&quot;&quot;&quot;花色&quot;&quot;&quot;
SPADE, HEART, CLUB, DIAMOND = range(4)
def __lt__(self, other):
    return self.value &lt; other.value</code></pre><p>  class Card():</p>
<pre><code>&quot;&quot;&quot;牌&quot;&quot;&quot;
def __init__(self, suite, face):
    &quot;&quot;&quot;初始化方法&quot;&quot;&quot;
    self.suite = suite
    self.face = face
def show(self):
    &quot;&quot;&quot;显示牌面&quot;&quot;&quot;
    suites = [&apos;♠️&apos;, &apos;♥️&apos;, &apos;♣️&apos;, &apos;♦️&apos;]
    faces = [&apos;&apos;, &apos;A&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;10&apos;, &apos;J&apos;, &apos;Q&apos;, &apos;K&apos;]
    return f&apos;{suites[self.suite.value]} {faces[self.face]}&apos;
def __str__(self):
    return self.show()
def __repr__(self):
    return self.show()</code></pre><p>  class Poker():</p>
<pre><code>&quot;&quot;&quot;扑克&quot;&quot;&quot;
def __init__(self):
    self.index = 0
    self.cards = [Card(suite, face)
                    for suite in Suite
                    for face in range(1, 14)]
def shuffle(self):
    &quot;&quot;&quot;洗牌（随机乱序）&quot;&quot;&quot;
    random.shuffle(self.cards)
    self.index = 0
def deal(self):
    &quot;&quot;&quot;发牌&quot;&quot;&quot;
    card = self.cards[self.index]
    self.index += 1
    return card
@property
def has_more(self):
    return self.index &lt; len(self.cards)</code></pre><p>  class Player():</p>
<pre><code>&quot;&quot;&quot;玩家&quot;&quot;&quot;
def __init__(self, name):
    self.name = name
    self.cards = []
def get_one(self, card):
    &quot;&quot;&quot;摸一张牌&quot;&quot;&quot;
    self.cards.append(card)
def sort(self, comp=lambda card: (card.suite, card.face)):
    &quot;&quot;&quot;整理手上的牌&quot;&quot;&quot;
    self.cards.sort(key=comp)</code></pre><p>  def main():</p>
<pre><code>&quot;&quot;&quot;主函数&quot;&quot;&quot;
poker = Poker()
poker.shuffle()
players = [Player(&apos;东邪&apos;), Player(&apos;西毒&apos;), Player(&apos;南帝&apos;), Player(&apos;北丐&apos;)]
while poker.has_more:
    for player in players:
            player.get_one(poker.deal())
for player in players:
    player.sort()
    print(player.name, end=&apos;: &apos;)
    print(player.cards)</code></pre><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:</p>
<pre><code>main()</code></pre><p><em>如果系统不支持emoji，可能无法显示花色</em></p>
</li>
<li><p>对象的复制（深拷贝/深复制/深度克隆和浅拷贝/浅复制/影子克隆)</p>
</li>
<li><p>垃圾回收、循环引用和弱引用<br>Python使用了自动化内存管理，这种管理机制以引用计数为基础，同时也引入了标记-清除和分代收集两种机制为辅的策略</p>
<p>  typedef struct_object {</p>
<pre><code>/* 引用计数 */
int ob_refcnt;
/* 对象指针 */
struct_typeobject *ob_type;</code></pre><p>  }PyObject;</p>
<p>  /* 增加引用计数的宏定义 <em>/<br>  #define Py_INCREF(op)  ((op)-&gt;ob_refcnt++)<br>  /</em> 减少引用计数的宏定义 */<br>  #define Py_DECREF(op) \ //减少计数</p>
<pre><code>if (--(op)-&gt;ob_refcnt != 0)\
    ; \
else \ 
    _Py_Dealloc((PyObject * )(op))</code></pre><p>导致引用计数+1的情况：<br>  对象被创建，例如 a = 23<br>  对象被引用，例如 b = a<br>  对象被作为参数，传入到一个函数中，例如f(a)<br>  对象作为一个元素，存储在容器中，例如list1 = [a, a]<br>导致引用计数-1的情况：<br>  对象的别名被显示销毁，例如 del a<br>  对象的别名被赋予新的对象，例如 a = 24<br>  一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会）<br>  对象所在的容器被销毁，或从容器中删除对象<br>引用计数可能会导致循环引用问题，而循环引用会导致内存泄漏，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活了下来，该对象会被放到第三代中</p>
<h1 id="循环引用会导致内存泄露-Python除了引用技术还引入了标记清理和分代回收"><a href="#循环引用会导致内存泄露-Python除了引用技术还引入了标记清理和分代回收" class="headerlink" title="循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收"></a>循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收</h1><h1 id="在Python-3-6以前如果重写del魔术方法会导致循环引用处理失效"><a href="#在Python-3-6以前如果重写del魔术方法会导致循环引用处理失效" class="headerlink" title="在Python 3.6以前如果重写del魔术方法会导致循环引用处理失效"></a>在Python 3.6以前如果重写<strong>del</strong>魔术方法会导致循环引用处理失效</h1><h1 id="如果不想造成循环引用可以使用弱引用"><a href="#如果不想造成循环引用可以使用弱引用" class="headerlink" title="如果不想造成循环引用可以使用弱引用"></a>如果不想造成循环引用可以使用弱引用</h1><p>  list1 = []<br>  list2 = []<br>  list1.append(list2)<br>  list2.append(list1)<br>以下情况会导致垃圾回收:<br>  调用gc.collect()<br>  gc模块的计数器达到阀值<br>  程序退出<br>如果循环引用中两个对象都定义了<strong>del</strong>方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的<strong>del</strong>方法，这个问题在Python 3.6中得到了解决。</p>
<p>也可以通过weakref模块构造弱引用的方式来解决循环引用的问题。</p>
</li>
<li><p>魔法属性和方法（参考《Python魔法方法指南》）<br>  有几个小问题：</p>
<pre><code>* 自定义的对象能不能使用运算符做运算？
* 自定义的对象能不能放到set中？能去重吗？
* 自定义的对象能不能作为dict的键？
* 自定义的对象能不能使用上下文语法？</code></pre></li>
<li><p>混入(Mixin)<br>  例：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对</p>
<p>  class SetOnceMappingMixin():</p>
<pre><code>&quot;&quot;&quot;自定义混入类&quot;&quot;&quot;
__slots__ = ()
def __setitem__(self, key, value):
    if key in self:
        raise KeyError(str(key) + &apos; already set&apos;)
    return super().__setitem__(key, value)</code></pre><p>  class SetOnceDict(SetOnceMappingMixin, dict):</p>
<pre><code>&quot;&quot;&quot;自定义字典&quot;&quot;&quot;
pass</code></pre><p>  my_dict= SetOnceDict()<br>  try:</p>
<pre><code>my_dict[&apos;username&apos;] = &apos;jackfrued&apos;
my_dict[&apos;username&apos;] = &apos;hellokitty&apos;</code></pre><p>  except KeyError:</p>
<pre><code>pass</code></pre><p>  print(my_dict)</p>
</li>
<li><p>元编程和元类<br>  例：元类实现单例模式</p>
<p>  import threading<br>  class SingletonMeta(type):</p>
<pre><code>&quot;&quot;&quot;自定义元类&quot;&quot;&quot;
def __init__(cls, *args, **kwargs):
    cls.__instance = None
    cls.__lock = threading.Lock()
    super().__init__(*args, **kwargs)
def __call__(cls, *args, **kwargs):
    if cls.__instance is None:
        with cls.__lock:
            if cls.__instance is None:
                cls.__instance = super().__call__(*args, **kwargs)
    return cls.__instance</code></pre><p>  class President(metaclass=SingletonMeta):</p>
<pre><code>&quot;&quot;&quot;总统(单例类)&quot;&quot;&quot;
pass</code></pre></li>
<li><p>面向对象设计原则<br>  单一职责原则(SRP)  一个类只做该做的事情（类的设计要高内聚）<br>  开闭原则（OCP）  软件实体应该对扩展开放对修改关闭<br>  依赖倒转原则（DIP）  面向抽象编程（在弱类型语言中已经被弱化）<br>  里氏替换原则（LSP）  任何时候可以用子类对象替换掉父类对象<br>  接口隔离原则（ISP)   接口要小而专不要大而全（python中没有接口概念）<br>  合成聚合复用原则（CARP)  优先使用强关联关系而不是继承关系复用代码<br>  最少知识原则（迪米特法则，LoD）  不要给没有必然联系的对象发消息<br>  上面的正好是面向对象的SOLID原则</p>
</li>
<li><p>GoF设计模式<br>  创建型模式：单例、工厂、建造者、原型<br>  结构型模式：适配器、门面（外观）、代理<br>  行为型模式：迭代器、观察者、状态、策略<br>  例：可插拔的哈希算法</p>
<p>  class StreamHasher():</p>
<pre><code>&quot;&quot;&quot;哈希摘要生成器(策略模式)&quot;&quot;&quot;
def __init__(self, alg=&apos;md5&apos;, size=4096):
    self.size = size
    alg = alg.lower()
    self.hasher = getattr(__import__(&apos;hashlib&apos;), alg.lower())()
def __call__(self, stream):
    return self.to_digest(stream)
def to_digest(self, stream):
    &quot;&quot;&quot;生成十六进制形式的摘要&quot;&quot;&quot;
    for buf in iter(lambda: stream.read(self.size), b&apos;&apos;):
        self.hasher.update(buf)
    return self.hasher.hexdigest()</code></pre><p>  def main():</p>
<pre><code>&quot;&quot;&quot;主函数&quot;&quot;&quot;
hasher1 = StreamHasher()
with open(&apos;Python-3.7.1.tgz&apos;, &apos;rb&apos;) as stream:
    print(hasher1.to_digest(stream))
hasher2 = StreamHasher(&apos;sha1&apos;)
with open(&apos;Python-3.7.1.tgz&apos;, &apos;rb&apos;) as stream:
    print(hasher2(stream))</code></pre><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:</p>
<pre><code>main()</code></pre></li>
</ul>
</li>
<li><p>迭代器和生成器</p>
<ul>
<li><p>和迭代器相关的魔术方法（<strong>iter</strong>和<strong>next</strong>)</p>
</li>
<li><p>两种创建生成器的方式（生成器表达式和yield关键字）</p>
<p>  def fib(num):</p>
<pre><code>&quot;&quot;&quot;生成器&quot;&quot;&quot;
a, b = 0, 1
for _ in range(num):
    a, b = b, a + b
    yield a</code></pre><p>  class Fib(object):</p>
<pre><code>&quot;&quot;&quot;迭代器&quot;&quot;&quot;
def __init__(self, num):
    self.num = num
    self.a, self.b = 0, 1
    self.idx = 0           
def __iter__(self):
    return self
def __next__(self):
    if self.idx &lt; self.num:
        self.a, self.b = self.b, self.a + self.b
        self.idx += 1
        return self.a
    raise StopIteration()</code></pre></li>
</ul>
</li>
<li><p>并发编程<br> Python中实现并发编程的三种方案：多线程 多进程 异步I/O。并发编程的好处在于<br> 可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说并不友好。</p>
<ul>
<li><p>多线程：Python中提供了Thread类并辅以Lock Condition Event Semaphore和<br>  Barrier。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于<br>  CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在<br>  多线程并不能发挥CPU的多核特性。</p>
<pre><code>&quot;&quot;&quot;</code></pre><p>  面试题：进程和线程的区别和联系？<br>  进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程<br>  线程 - 操作系统分配CPU的基本单位<br>  并发编程（concurrent programming）</p>
<ol>
<li><p>提升执行性能 - 让程序中没有因果关系的部分可以并发的执行</p>
</li>
<li><p>改善用户体验 - 让耗时间的操作不会造成程序的假死<br>“””<br>import glob<br>import os<br>import threading<br>from PIL import Image<br>PREFIX = ‘thumbnails’<br>def generate_thumbnail(infile, size, format=’PNG’):<br> “””生成指定图片文件的缩略图”””<br> file, ext = os.path.splitext(infile)<br> file = file[file.rfind(‘/‘) + 1:]<br> outfile = f’{PREFIX}/{file}<em>{size[0]}</em>{size[1]}.{ext}’<br> img = Image.open(infile)<br> img.thumbnail(size, Image.ANTIALIAS)<br> img.save(outfile, format)<br>def main():<br> “””主函数”””<br> if not os.path.exists(PREFIX):</p>
<pre><code>os.mkdir(PREFIX)</code></pre><p> for infile in glob.glob(‘images/*.png’):</p>
<pre><code>for size in (32, 64, 128):
    # 创建并启动线程
    threading.Thread(
        target=generate_thumbnail, 
        args=(infile, (size, size))
    ).start()</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br> main()<br>多个线程竞争资源的情况</p>
<p>“””<br>多线程程序如果没有竞争资源处理起来通常也比较简单<br>当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱<br>说明：临界资源就是被多个线程竞争的资源<br>“””<br>import time<br>import threading<br>from concurrent.futures import ThreadPoolExecutor<br>class Account(object):<br> “””银行账户”””<br> def <strong>init</strong>(self):</p>
<pre><code>self.balance = 0.0
self.lock = threading.Lock()</code></pre><p> def deposit(self, money):</p>
<pre><code># 通过锁保护临界资源
with self.lock:
    new_balance = self.balance + money
    time.sleep(0.001)
    self.balance = new_balance</code></pre><p>class AddMoneyThread(threading.Thread):<br> “””自定义线程类”””<br> def <strong>init</strong>(self, account, money):</p>
<pre><code>self.account = account
self.money = money
# 自定义线程的初始化方法中必须调用父类的初始化方法
super().__init__()</code></pre><p> def run(self):</p>
<pre><code># 线程启动之后要执行的操作
self.account.deposit(self.money)</code></pre><p>def main():<br> “””主函数”””<br> account = Account()</p>
<h1 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h1><p> pool = ThreadPoolExecutor(max_workers=10)<br> futures = []<br> for _ in range(100):</p>
<pre><code># 创建线程的第1种方式
# threading.Thread(
#     target=account.deposit, args=(1, )
# ).start()
# 创建线程的第2种方式
# AddMoneyThread(account, 1).start()
# 创建线程的第3种方式
# 调用线程池中的线程来执行特定的任务
future = pool.submit(account.deposit, 1)
futures.append(future)</code></pre><h1 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h1><p> pool.shutdown()<br> for future in futures:</p>
<pre><code>future.result()</code></pre><p> print(account.balance)<br>if <strong>name</strong> == ‘<strong>main</strong>‘:<br> main()<br>修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用threading模块的Condition来实现线程调度，该对象也是基于锁来创建的，代码如下所示：</p>
<p>“””<br>多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock）<br>多个线程竞争多个资源（线程数&gt;资源数） - 信号量（Semaphore）<br>多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition<br>“””<br>from concurrent.futures import ThreadPoolExecutor<br>from random import randint<br>from time import sleep<br>import threading<br>class Account():<br> “””银行账户”””<br> def <strong>init</strong>(self, balance=0):</p>
<pre><code>self.balance = balance
lock = threading.Lock()
self.condition = threading.Condition(lock)</code></pre><p> def withdraw(self, money):</p>
<pre><code>&quot;&quot;&quot;取钱&quot;&quot;&quot;
with self.condition:
    while money &gt; self.balance:
        self.condition.wait()
    new_balance = self.balance - money
    sleep(0.001)
    self.balance = new_balance</code></pre><p> def deposit(self, money):</p>
<pre><code>&quot;&quot;&quot;存钱&quot;&quot;&quot;
with self.condition:
    new_balance = self.balance + money
    sleep(0.001)
    self.balance = new_balance
    self.condition.notify_all()</code></pre><p>def add_money(account):<br> while True:</p>
<pre><code>money = randint(5, 10)
account.deposit(money)
print(threading.current_thread().name, 
    &apos;:&apos;, money, &apos;====&gt;&apos;, account.balance)
sleep(0.5)</code></pre><p>def sub_money(account):<br> while True:</p>
<pre><code>money = randint(10, 30)
account.withdraw(money)
print(threading.current_thread().name, 
    &apos;:&apos;, money, &apos;&lt;====&apos;, account.balance)
sleep(1)</code></pre><p>def main():<br> account = Account()<br> with ThreadPoolExecutor(max_workers=10) as pool:</p>
<pre><code>for _ in range(5):
    pool.submit(add_money, account)
    pool.submit(sub_money, account)</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br> main()</p>
</li>
</ol>
</li>
<li><p>多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是Process，其他<br>  辅助的类跟threading模块中的类似，进程间共享数据可以使用管道、套接字等，在multiprocessing模块中有一个Queue类，它基于管道和锁机制提供了多个进程共享的队列。</p>
<p>  “””<br>  多进程和进程池的使用<br>  多线程因为GIL的存在不能够发挥CPU的多核特性<br>  对于计算密集型任务应该考虑使用多进程<br>  time python3 example22.py<br>  real    0m11.512s<br>  user    0m39.319s<br>  sys     0m0.169s<br>  使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍<br>  这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU<br>  “””<br>  import concurrent.futures<br>  import math<br>  PRIMES = [</p>
<pre><code>1116281,
1297337,
104395303,
472882027,
533000389,
817504243,
982451653,
112272535095293,
112582705942171,
112272535095293,
115280095190773,
115797848077099,
1099726899285419</code></pre><p>  ] * 5<br>  def is_prime(n):</p>
<pre><code>&quot;&quot;&quot;判断素数&quot;&quot;&quot;
if n % 2 == 0:
    return False
sqrt_n = int(math.floor(math.sqrt(n)))
for i in range(3, sqrt_n + 1, 2):
    if n % i == 0:
        return False
return True</code></pre><p>  def main():</p>
<pre><code>&quot;&quot;&quot;主函数&quot;&quot;&quot;
with concurrent.futures.ProcessPoolExecutor() as executor:
    for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):
        print(&apos;%d is prime: %s&apos; % (number, prime))</code></pre><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:</p>
<pre><code>main()</code></pre><p>多进程和多线程的比较<br>以下情况需要使用多线程:</p>
<p>  程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。<br>  程序会花费大量时间在IO操作上，没有太多并行计算的需求且不需占用太多的内存。</p>
<p>以下情况需要使用多进程：</p>
<p>  程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。<br>  程序的输入可以并行的分成块，并且可以将运算结果合并。<br>  程序在内存使用方面没有任何限制且不强依赖于IO操作（如：读写文件、套接字等）。</p>
</li>
<li><p>异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些        任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的        一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务        协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编        程或者future对象来获取任务执行的结果。Python3通过asyncio模块和await        和async关键字（在Python 3.7中正式被列为关键字）来支持异步处理。</p>
<p>  “””<br>  异步I/O - async / await<br>  “””<br>  import asyncio<br>  def num_generator(m, n):</p>
<pre><code>&quot;&quot;&quot;指定范围的数字生成器&quot;&quot;&quot;
yield from range(m, n + 1)</code></pre><p>  async def prime_filter(m, n):</p>
<pre><code>&quot;&quot;&quot;素数过滤器&quot;&quot;&quot;
primes = []
for i in num_generator(m, n):
    flag = True
    for j in range(2, int(i ** 0.5 + 1)):
        if i % j == 0:
            flag = False
            break
    if flag:
        print(&apos;Prime =&gt;&apos;, i)
        primes.append(i)
    await asyncio.sleep(0.001)
return tuple(primes)</code></pre><p>  async def square_mapper(m, n):</p>
<pre><code>&quot;&quot;&quot;平方映射器&quot;&quot;&quot;
squares = []
for i in num_generator(m, n):
    print(&apos;Square =&gt;&apos;, i * i)
    squares.append(i * i)
    await asyncio.sleep(0.001)
return squares</code></pre><p>  def main():</p>
<pre><code>&quot;&quot;&quot;主函数&quot;&quot;&quot;
loop = asyncio.get_event_loop()
future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100))
future.add_done_callback(lambda x: print(x.result()))
loop.run_until_complete(future)
loop.close()</code></pre><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:</p>
<pre><code>main()</code></pre><p><em>上面的代码使用get_event_loop函数获得系统默认的事件循环，通过gather函数可以获得一个future对象，future对象的add_done_callback可以添加执行完成时的回调函数，loop对象的run_until_complete方法可以等待通过future对象获得协程执行结果。</em><br>Python中有一个名为aiohttp的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟asyncio模块一起工作，并提供了对Future对象的支持。Python 3.6中引入了async和await来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。</p>
<p>  import asyncio<br>  import re<br>  import aiohttp<br>  PATTERN = re.compile(r’&lt;title&gt;(?P<title>.*)&lt;/title&gt;‘)<br>  async def fetch_page(session, url):</title></p>
<pre><code>async with session.get(url, ssl=False) as resp:
    return await resp.text()</code></pre><p>  async def show_title(url):</p>
<pre><code>async with aiohttp.ClientSession() as session:
    html = await fetch_page(session, url)
    print(PATTERN.search(html).group(&apos;title&apos;))</code></pre><p>  def main():</p>
<pre><code>urls = (&apos;https://www.python.org/&apos;,
        &apos;https://git-scm.com/&apos;,
        &apos;https://www.jd.com/&apos;,
        &apos;https://www.taobao.com/&apos;,
        &apos;https://www.douban.com/&apos;)
loop = asyncio.get_event_loop()
tasks = [show_title(url) for url in urls]
loop.run_until_complete(asyncio.wait(tasks))
loop.close()</code></pre><p>  if <strong>name</strong> == ‘<strong>main</strong>‘:</p>
<pre><code>main()</code></pre><p>异步I/O与多进程的比较<br>当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，asyncio就是一种很好的选择，如果程序中有大量的等待和休眠时，也应该考虑asyncio，他很适合编写没有实时数据处理需求的web应用服务器</p>
<p>Python还有很多用于处理并行任务的三方库，例如：joblib、PyMP等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。</p>
<p>要实现任务的异步化，可以使用名为Celery的三方库。Celery是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。</p>
</li>
</ul>
</li>
</ol>

    </div>

    
    
    
        
      

      <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/10/08/python015/" rel="next" title="python015">
                  <i class="fa fa-chevron-left"></i> python015
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/10/16/Web前端概述/" rel="prev" title="Web前端概述">
                  Web前端概述 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Python语言进阶"><span class="nav-number">1.</span> <span class="nav-text">Python语言进阶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#循环引用会导致内存泄露-Python除了引用技术还引入了标记清理和分代回收"><span class="nav-number">2.</span> <span class="nav-text">循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在Python-3-6以前如果重写del魔术方法会导致循环引用处理失效"><span class="nav-number">3.</span> <span class="nav-text">在Python 3.6以前如果重写del魔术方法会导致循环引用处理失效</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如果不想造成循环引用可以使用弱引用"><span class="nav-number">4.</span> <span class="nav-text">如果不想造成循环引用可以使用弱引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#创建线程池"><span class="nav-number">5.</span> <span class="nav-text">创建线程池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关闭线程池"><span class="nav-number">6.</span> <span class="nav-text">关闭线程池</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/bayhax.jpg"
      alt="王洪粮">
  <p class="site-author-name" itemprop="name">王洪粮</p>
  <div class="site-description" itemprop="description">坚持  自律   幽默  乐观 向上</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
  </nav>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/bayhax" title="GitHub &rarr; https://github.com/bayhax" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="mailto:whlbayhax@gmail.com" title="E-Mail &rarr; mailto:whlbayhax@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">by bayhax</span>
</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/pisces.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
